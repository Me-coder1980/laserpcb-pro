// ===============================
// GLOBALS
// ===============================

let gerberData = null;
let paths = [];
let copperPaths = [];
let isolationPaths = [];
let scale = 15;                    // Zoom scaling
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

let laserPort = null;
let laserWriter = null;
let isLaserRunning = false;

const canvas = document.getElementById("pcbCanvas");
const ctx = canvas.getContext("2d");

canvas.addEventListener("wheel", (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    const zoomFactor = 1.1;
    const oldScale = scale;

    if (e.deltaY < 0) {
        scale *= zoomFactor;
    } else {
        scale /= zoomFactor;
    }

    offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
    offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);

    draw();
});

canvas.addEventListener("mousedown", (e) => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});
canvas.addEventListener("mouseup", () => { isDragging = false; });
canvas.addEventListener("mouseleave", () => { isDragging = false; });

canvas.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    let dx = e.clientX - lastMouseX;
    let dy = e.clientY - lastMouseY;

    offsetX += dx;
    offsetY += dy;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    draw();
});
function log(msg) {
    const box = document.getElementById("consoleOutput");
    box.value += msg + "\n";
    box.scrollTop = box.scrollHeight;
}

// ===============================
// PARSING GERBER
// ===============================

document.getElementById("fileInput").addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (ev) {
        gerberData = ev.target.result;
        log("Gerber file loaded.");
        parseGerber(gerberData);
    };
    reader.readAsText(file);
});

function parseGerber(data) {
    paths = [];
    let lines = data.split("\n");
    let x = 0, y = 0;
    let currentPath = [];

    for (let line of lines) {
        line = line.trim();
        if (line.startsWith("X") || line.startsWith("Y")) {
            let newX = x;
            let newY = y;

            let mx = line.match(/X(-?\d+)/);
            let my = line.match(/Y(-?\d+)/);

            if (mx) newX = parseInt(mx[1]) / 10000;
            if (my) newY = parseInt(my[1]) / 10000;

            if (line.endsWith("D01*")) {
                currentPath.push([newX, newY]);
            } else if (line.endsWith("D02*")) {
                if (currentPath.length > 1) paths.push(currentPath);
                currentPath = [[newX, newY]];
            }
            x = newX;
            y = newY;
        }
    }

    if (currentPath.length > 1) paths.push(currentPath);
    log("Parsed " + paths.length + " copper traces.");
    copperPaths = paths;
    draw();
}
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    ctx.strokeStyle = "#00ff88";
    ctx.lineWidth = 0.1;

    for (let p of copperPaths) {
        ctx.beginPath();
        ctx.moveTo(p[0][0], -p[0][1]);
        for (let i = 1; i < p.length; i++) {
            ctx.lineTo(p[i][0], -p[i][1]);
        }
        ctx.stroke();
    }

    ctx.strokeStyle = "#ff4444";
    for (let p of isolationPaths) {
        ctx.beginPath();
        ctx.moveTo(p[0][0], -p[0][1]);
        for (let i = 1; i < p.length; i++) {
            ctx.lineTo(p[i][0], -p[i][1]);
        }
        ctx.stroke();
    }

    ctx.restore();
}

function generateCopper() {
    log("Copper paths generated.");
    copperPaths = paths;
    draw();
}
function generateIsolation() {
    let iso = parseFloat(document.getElementById("isolation").value) || 0.2;
    isolationPaths = [];

    for (let p of copperPaths) {
        let expanded = offsetPoly(p, iso);
        if (expanded.length > 1) isolationPaths.push(expanded);
    }

    log("Isolation generated: " + isolationPaths.length + " offset traces.");
    draw();
}

function offsetPoly(poly, dist) {
    let off = new ClipperLib.ClipperOffset();
    let path = poly.map(pt => ({ X: pt[0], Y: pt[1] }));
    off.AddPath(path, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etOpenRound);

    let result = [];
    off.Execute(result, dist);

    if (result.length === 0) return [];
    return result[0].map(pt => [pt.X, pt.Y]);
}
function generateGcode() {
    let power = parseInt(document.getElementById("laserPower").value) || 50;
    let feed = parseInt(document.getElementById("feedRate").value) || 300;

    let g = [];
    g.push("G21 ; mm");
    g.push("G90 ; absolute");
    g.push("M4 S0");

    for (let path of copperPaths) {
        g.push(`G0 X${path[0][0].toFixed(3)} Y${path[0][1].toFixed(3)}`);
        g.push(`M4 S${power}`);

        for (let i = 1; i < path.length; i++) {
            g.push(`G1 X${path[i][0].toFixed(3)} Y${path[i][1].toFixed(3)} F${feed}`);
        }

        g.push("M4 S0");
    }

    let blob = new Blob([g.join("\n")], { type: "text/plain" });
    let url = URL.createObjectURL(blob);

    let a = document.createElement("a");
    a.href = url;
    a.download = "laserpcb.gcode";
    a.click();

    URL.revokeObjectURL(url);
    log("G-Code exported.");
}
function zoomIn() {
    scale *= 1.2;
    draw();
}
function zoomOut() {
    scale /= 1.2;
    draw();
}

// ===============================
// LASER SERIAL CONNECT
// ===============================

async function connectLaser() {
    try {
        laserPort = await navigator.serial.requestPort();
        await laserPort.open({ baudRate: 115200 });

        laserWriter = laserPort.writable.getWriter();
        log("Connected to laser.");
    } catch (e) {
        log("Laser connect error: " + e);
    }
}

async function sendGcodeLine(line) {
    if (!laserWriter) return;
    await laserWriter.write(new TextEncoder().encode(line + "\n"));
}
async function startLaserJob() {
    if (isLaserRunning) {
        log("Laser already running");
        return;
    }

    if (!laserWriter) {
        log("Laser not connected!");
        return;
    }

    isLaserRunning = true;
    log("Starting laser job...");

    let power = parseInt(document.getElementById("laserPower").value) || 50;
    let feed = parseInt(document.getElementById("feedRate").value) || 300;

    for (let path of copperPaths) {
        await sendGcodeLine(`G0 X${path[0][0]} Y${path[0][1]}`);
        await sendGcodeLine(`M4 S${power}`);

        for (let i = 1; i < path.length; i++) {
            await sendGcodeLine(`G1 X${path[i][0]} Y${path[i][1]} F${feed}`);
        }

        await sendGcodeLine("M4 S0");
    }

    isLaserRunning = false;
    log("Laser job complete.");
}
window.onload = () => {
    draw();
};

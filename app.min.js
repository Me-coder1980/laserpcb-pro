// ====== Globale state ======
let copperPaths = [];     // array van polylines: [[{x,y},...], ...]
let isoPaths = [];        // offset / isolatie
let drillHoles = [];      // {x,y,diam}
let gcodeLines = [];

let scale = 15;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let lastX = 0;
let lastY = 0;

const canvas = document.getElementById("pcbCanvas");
const ctx = canvas.getContext("2d");
const logBox = document.getElementById("consoleOutput");

let laserPort = null;
let laserWriter = null;
let laserRunning = false;
let laserPaused = false;

// ====== Logging ======
function log(msg){
  logBox.value += msg + "\n";
  logBox.scrollTop = logBox.scrollHeight;
}

// ====== Canvas helpers ======
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = (rect.height||600) * window.devicePixelRatio;
  ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
  draw();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  const mx = e.offsetX;
  const my = e.offsetY;
  const oldScale = scale;
  const factor = e.deltaY<0 ? 1.1 : 0.9;
  scale *= factor;
  offsetX = mx - (mx-offsetX)*(scale/oldScale);
  offsetY = my - (my-offsetY)*(scale/oldScale);
  draw();
},{passive:false});

canvas.addEventListener("mousedown",e=>{
  isDragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mouseup",()=>{isDragging=false;});
canvas.addEventListener("mouseleave",()=>{isDragging=false;});
canvas.addEventListener("mousemove",e=>{
  if(!isDragging) return;
  const dx = e.clientX-lastX;
  const dy = e.clientY-lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  offsetX += dx;
  offsetY += dy;
  draw();
});

// ====== File inputs ======
document.getElementById("gtlInput").addEventListener("change",e=>{
  const file = e.target.files[0];
  if(!file) return;
  document.getElementById("gtlName").textContent = file.name;
  const r = new FileReader();
  r.onload = ev=>{
    parseGerberTop(ev.target.result);
  };
  r.readAsText(file);
});

document.getElementById("drlInput").addEventListener("change",e=>{
  const file = e.target.files[0];
  if(!file) return;
  document.getElementById("drlName").textContent = file.name;
  const r = new FileReader();
  r.onload = ev=>{
    parseDrill(ev.target.result);
  };
  r.readAsText(file);
});

// ====== Gerber parser (simpele lijn-parser, EasyEDA compatible) ======
function parseGerberTop(text){
  copperPaths = [];
  isoPaths = [];
  let x=0, y=0;
  let current = [];
  const lines = text.split(/\r?\n/);

  for(let raw of lines){
    const line = raw.trim();
    if(!line || line.startsWith("G04") || line.startsWith("%")) continue;

    if(line[0]==="X" || line[0]==="Y"){
      let nx = x, ny = y;
      const mx = line.match(/X(-?\d+)/);
      const my = line.match(/Y(-?\d+)/);
      if(mx) nx = parseInt(mx[1],10)/10000.0;
      if(my) ny = parseInt(my[1],10)/10000.0;

      if(line.endsWith("D01*")){      // draw
        current.push({x:nx,y:ny});
      }else if(line.endsWith("D02*")){ // move
        if(current.length>1) copperPaths.push(current);
        current = [{x:nx,y:ny}];
      }
      x=nx; y=ny;
    }
  }
  if(current.length>1) copperPaths.push(current);

  log("Toplayer geladen. Traces: "+copperPaths.length);
  updateStats();
  autoCenter();
  draw();
}

// HEEL simpele Excellon drill parser: X..Y.. per gat
function parseDrill(text){
  drillHoles = [];
  const lines = text.split(/\r?\n/);
  let toolDiam = 0.6; // default 0.6mm
  const toolTable = {};

  for(let raw of lines){
    const line = raw.trim();
    if(line.startsWith("T") && line.includes("C")){
      // T1C0.8
      const mt = line.match(/^T(\d+)C([\d\.]+)/);
      if(mt){
        toolTable[mt[1]] = parseFloat(mt[2]);
      }
    }else if(line.startsWith("T") && !line.includes("C")){
      const tn = line.substring(1);
      if(toolTable[tn]) toolDiam = toolTable[tn];
    }else if(line.startsWith("X")){
      const mx = line.match(/X(-?\d+)/);
      const my = line.match(/Y(-?\d+)/);
      if(mx && my){
        const x = parseInt(mx[1],10)/10000.0;
        const y = parseInt(my[1],10)/10000.0;
        drillHoles.push({x,y,diam:toolDiam});
      }
    }
  }
  log("Drill file geladen. Gaten: "+drillHoles.length);
  updateStats();
  draw();
}

// ====== Stats + center ======
function updateStats(){
  if(copperPaths.length===0){
    document.getElementById("statusDims").textContent="Afmetingen: –";
    document.getElementById("statusTraces").textContent="Traces: 0";
    return;
  }
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const path of copperPaths){
    for(const p of path){
      if(p.x<minX) minX=p.x;
      if(p.x>maxX) maxX=p.x;
      if(p.y<minY) minY=p.y;
      if(p.y>maxY) maxY=p.y;
    }
  }
  const w = maxX-minX;
  const h = maxY-minY;
  document.getElementById("statusDims").textContent=
    `Afmetingen: ${w.toFixed(2)} x ${h.toFixed(2)} mm`;
  document.getElementById("statusTraces").textContent=
    `Traces: ${copperPaths.length}`;
}

function autoCenter(){
  if(copperPaths.length===0) return;
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const path of copperPaths){
    for(const p of path){
      if(p.x<minX) minX=p.x;
      if(p.x>maxX) maxX=p.x;
      if(p.y<minY) minY=p.y;
      if(p.y>maxY) maxY=p.y;
    }
  }
  const cx = (minX+maxX)/2;
  const cy = (minY+maxY)/2;
  const rect = canvas.getBoundingClientRect();
  offsetX = rect.width/2 - cx*scale;
  offsetY = rect.height/2 + cy*scale;
}

// ====== Tekenen ======
function draw(){
  const rect = canvas.getBoundingClientRect();
  ctx.clearRect(0,0,rect.width,rect.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, -scale);

  // copper
  ctx.lineWidth = 0.18;
  ctx.strokeStyle = "#00ff88";
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  for(const path of copperPaths){
    if(path.length<2) continue;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
  }

  // iso
  ctx.strokeStyle = "#ff4444";
  ctx.lineWidth = 0.08;
  for(const path of isoPaths){
    if(path.length<2) continue;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for(let i=1;i<path.length;i++){
      ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
  }

  // drills
  ctx.fillStyle="#000000";
  ctx.strokeStyle="#ffcc00";
  for(const h of drillHoles){
    const r = (h.diam||0.6)/2;
    ctx.beginPath();
    ctx.arc(h.x,h.y,r,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
  }

  ctx.restore();
}

// ====== Isolatie genereren ======
function generateIsolation(){
  if(copperPaths.length===0){
    alert("Laad eerst een .GTL bestand");
    return;
  }
  const iso = parseFloat(document.getElementById("isoDistance").value)||0.06;
  const passes = Math.max(1,parseInt(document.getElementById("passes").value)||1);

  isoPaths = [];
  const co = new ClipperLib.ClipperOffset(2,0.01);

  for(const path of copperPaths){
    const clipPath = path.map(p=>({X:p.x,Y:p.y}));
    for(let pass=1;pass<=passes;pass++){
      const dist = iso*pass;
      const result = [];
      co.Clear();
      co.AddPath(clipPath,ClipperLib.JoinType.jtRound,ClipperLib.EndType.etOpenRound);
      co.Execute(result,dist);
      if(result.length>0){
        const poly = result[0].map(p=>({x:p.X,y:p.Y}));
        isoPaths.push(poly);
      }
    }
  }
  log(`Isolatie gegenereerd: ${isoPaths.length} paden, passes: ${passes}`);
  draw();
}

// ====== G-code genereren ======
function generateGcode(){
  if(isoPaths.length===0 && copperPaths.length===0){
    alert("Geen paden om G-code van te maken. Genereer eerst isolatie.");
    return;
  }

  const feedCut   = parseInt(document.getElementById("feedCut").value)||500;
  const feedTrav  = parseInt(document.getElementById("feedTravel").value)||3000;
  const power     = parseInt(document.getElementById("laserPower").value)||250;
  const drillArm  = parseFloat(document.getElementById("drillArm").value)||0.2;

  const lines = [];
  lines.push("; Isolation G-code generated by LaserPCB PRO");
  lines.push("G21");
  lines.push("G90");
  lines.push("G0 X0 Y0");
  lines.push("M4 S0");

  function addPath(path){
    if(path.length<2) return;
    lines.push(`G0 X${path[0].x.toFixed(3)} Y${path[0].y.toFixed(3)} F${feedTrav}`);
    lines.push(`M4 S${power}`);
    for(let i=1;i<path.length;i++){
      lines.push(`G1 X${path[i].x.toFixed(3)} Y${path[i].y.toFixed(3)} F${feedCut}`);
    }
    lines.push("M4 S0");
  }

  // iso eerst
  for(const p of isoPaths) addPath(p);
  // copper (optioneel mee graveren)
  for(const p of copperPaths) addPath(p);

  // cross marks voor drill holes
  for(const h of drillHoles){
    const r = drillArm/2;
    const x = h.x.toFixed(3);
    const y = h.y.toFixed(3);
    lines.push(`G0 X${x} Y${y} F${feedTrav}`);
    lines.push(`M4 S${power}`);
    lines.push(`G1 X${(h.x-r).toFixed(3)} Y${y} F${feedCut}`);
    lines.push(`G1 X${(h.x+r).toFixed(3)} Y${y} F${feedCut}`);
    lines.push(`G0 X${x} Y${y} F${feedTrav}`);
    lines.push(`G1 X${x} Y${(h.y-r).toFixed(3)} F${feedCut}`);
    lines.push(`G1 X${x} Y${(h.y+r).toFixed(3)} F${feedCut}`);
    lines.push("M4 S0");
  }

  lines.push("M4 S0");
  lines.push("G0 X0 Y0");
  gcodeLines = lines;

  document.getElementById("gcodePreview").value = lines.join("\n");
  log("G-code gegenereerd. Regels: "+lines.length);
}

function downloadGcode(){
  if(!gcodeLines.length){
    alert("Genereer eerst G-code.");
    return;
  }
  const blob = new Blob([gcodeLines.join("\n")],{type:"text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "laserpcb_pro.gcode";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  log("G-code gedownload.");
}

// ====== WebSerial laser ======
async function connectLaser(){
  try{
    laserPort = await navigator.serial.requestPort();
    await laserPort.open({baudRate:115200});
    laserWriter = laserPort.writable.getWriter();
    log("Laser verbonden.");
  }catch(e){
    log("Fout bij verbinden laser: "+e);
  }
}

async function sendLine(line){
  if(!laserWriter) return;
  const enc = new TextEncoder();
  await laserWriter.write(enc.encode(line+"\n"));
}

async function runJob(){
  if(!gcodeLines.length){
    alert("Geen G-code aanwezig.");
    return;
  }
  if(!laserWriter){
    alert("Nog geen laser verbonden.");
    return;
  }
  laserRunning = true;
  laserPaused = false;
  log("Job gestart...");

  for(const line of gcodeLines){
    if(!laserRunning) break;
    while(laserPaused){
      await new Promise(r=>setTimeout(r,100));
    }
    await sendLine(line);
    await new Promise(r=>setTimeout(r,5));
  }
  laserRunning = false;
  log("Job klaar of gestopt.");
}

function pauseJob(){
  if(!laserRunning) return;
  laserPaused = !laserPaused;
  log(laserPaused ? "Job gepauzeerd." : "Job hervat.");
}

async function stopJob(){
  laserRunning = false;
  laserPaused = false;
  try{
    await sendLine("M4 S0");
  }catch(_){}
  log("Noodstop verzonden.");
}

// ====== Event handlers UI ======
document.getElementById("btnGenerateIso").addEventListener("click",()=>{
  generateIsolation();
});
document.getElementById("btnDownloadGcode").addEventListener("click",downloadGcode);
document.getElementById("btnConnect").addEventListener("click",connectLaser);
document.getElementById("btnStartJob").addEventListener("click",runJob);
document.getElementById("btnPause").addEventListener("click",pauseJob);
document.getElementById("btnStop").addEventListener("click",stopJob);

// init
log("LaserPCB PRO – Optie B + PadProtect geladen.");
